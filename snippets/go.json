{
  "todo gamidli": {
    "prefix": "todo",
    "body": ["// TODO(ig): "]
  },

  "test structure": {
    "prefix": "test structure",
    "body": [
      "func Test${1:Function}(t *testing.T) {",
      "\ttype given struct {}",
      "\ttype expected struct {}",
      "\ttests := []struct {",
      "\t\tname     string",
      "\t\tgiven    given",
      "\t\texpected expected",
      "\t}{{name: \"first test\", given: given{}, expected: expected{}}}",
      "\tfor _, tt := range tests {",
      "\t\tt.Run(tt.name, func(t *testing.T) {})",
      "\t}",
      "}"
    ]
  },
  "lro process function": {
    "prefix": "lro process function",
    "body": [
      "func (svc *${1:Service}) process${2:Function}(ctx context.Context, op *operation.Operation, completeStep operation.CompleteStep) (err error) {",
      "\tif op.LastCompletedStep < ${3:step} {",
      "\t\terr = svc.${3:step}(ctx, op, completeStep)",
      "\t\tif err != nil {",
      "\t\t\treturn operation.NewTechnicalError(",
      "\t\t\t\tcodes.Internal,",
      "\t\t\t\terr,",
      "\t\t\t\toperation.Permanent,",
      "\t\t\t)",
      "\t\t}",
      "\t}",
      "",
      "\treturn nil",
      "}"
    ]
  },
  "lro step function": {
    "prefix": "lro step function",
    "body": [
      "func (svc *${1:Service}) ${2:step}(ctx context.Context, op *operation.Operation, completeStep operation.CompleteStep) (err error) {",
      "\tctx, linkedSpans := tracing.StartLinkedSpans(ctx, \"${2:step}\")",
      "\tdefer func() {",
      "\t\tif err != nil {",
      "\t\t\tlinkedSpans.RecordError(err)",
      "\t\t\tlinkedSpans.SetStatus(tracecodes.Error, err.Error())",
      "\t\t}",
      "\t\tlinkedSpans.End()",
      "\t}()",
      "",
      "\tcustomData := ${3:customDataType}{}",
      "\terr = json.Unmarshal(op.CustomDataJson, &customData)",
      "\tif err != nil {",
      "\t\treturn fmt.Errorf(\"could not unmarshal operation custom data as ${3:customDataType}: %w\", err)",
      "\t}",
      "",
      "\top.CustomDataJson, err = json.Marshal(customData)",
      "\tif err != nil {",
      "\t\treturn fmt.Errorf(\"marshal custom data json: %w\", err)",
      "\t}",
      "",
      "\terr = completeStep(ctx, ${2:step}, \"\", op.CustomDataJson)",
      "\tif err != nil {",
      "\t\treturn fmt.Errorf(\"could not set step ${2:step} as completed: %w\", err)",
      "\t}",
      "",
      "\treturn nil",
      "}"
    ]
  },
  "new pager": {
    "prefix": "new pager",
    "body": [
      "${4:pager} := paging.NewPager(",
      "\t(*${1:pb}.List${2:Item}Response).Get${2:Item},",
      "\tfunc(ctx context.Context, pageToken string) (*${1:pb}.List${2:Item}Response, error) {",
      "\t\treturn retry.Backoff(ctx, retry.LongrunningConfig(), func(ctx context.Context) (*${1:pb}.List${2:Item}Response, error) {",
      "\t\t\treturn svc.${3:client}.List${2:Item}(ctx, &${1:pb}.List${2:Item}Request{",
      "\t\t\t\tPageSize:  paging.DefaultPageSize,",
      "\t\t\t\tPageToken: pageToken,",
      "\t\t\t})",
      "\t\t})",
      "\t},",
      ")",
      "for _, err := range ${4:pager}.All(ctx, paging.AllPages) {",
      "\tif err != nil {",
      "\t\treturn fmt.Errorf(\"error fetching ${2:Item}: %w\", err)",
      "\t}",
      "}"
    ]
  },
  "print json": {
    "prefix": "print json",
    "body": [
      "${1:item}Json, _ := json.MarshalIndent(${1:item}, \"\", \"  \")",
      "fmt.Fprintf(os.Stderr, \"DEBUGPRINT: ${1:item}=%s\\n\", string(${1:item}Json))"
    ]
  },
  "validate request": {
    "prefix": "validate request",
    "body": [
      "filters, err := validate${1:FunctionName}Request(req)",
      "if err != nil {",
      "\treturn nil, err",
      "}",
      "",
      "func validate${1:FunctionName}Request(req *pb.${1:FunctionName}Request) (filters *${2:FiltersType}, err error) {",
      "\tif req.Filter == nil {",
      "\t\treturn nil, nil",
      "\t}",
      "",
      "\tviolations := make([]*errdetails.BadRequest_FieldViolation, 0)",
      "\tfilters = &${2:FiltersType}{}",
      "",
      "\tfor i, f := range req.GetAnd().Filters {",
      "\t\tswitch fTyped := f.Filter.(type) {",
      "\t\tcase *pb.${3:FilterType}_${4:FieldName}:",
      "\t\t\tif violation := ${5:validation}.Validate(fmt.Sprintf(\"filters[%d].${6:field_name}\", i), fTyped.${4:FieldName}); violation != nil {",
      "\t\t\t\tviolations = append(violations, violation)",
      "\t\t\t}",
      "\t\t\tfilters.${4:FieldName} = fTyped.${4:FieldName}",
      "\t\t${7:// Add more cases here}",
      "\t\tdefault:",
      "\t\t\tviolations = append(violations, &errdetails.BadRequest_FieldViolation{",
      "\t\t\t\tField:       fmt.Sprintf(\"filters[%d]\", i),",
      "\t\t\t\tDescription: fmt.Sprintf(\"Unknown filter: %T\", fTyped),",
      "\t\t\t})",
      "\t\t}",
      "\t}",
      "",
      "\tviolations = validation.JoinFieldViolations(violations...)",
      "",
      "\tif len(violations) > 0 {",
      "\t\treturn nil, status.Error(status.ErrorOptions{",
      "\t\t\tCode:            codes.InvalidArgument,",
      "\t\t\tFieldViolations: violations,",
      "\t\t})",
      "\t}",
      "",
      "\treturn filters, nil",
      "}"
    ]
  },
  "service client": {
    "prefix": "service client",
    "body": [
      "type ${1:serviceName}ServiceClient interface {",
      "\t${2:Method1}(ctx context.Context, request *${3:PackageName}.${2:Method1}Request, opts ...grpc.CallOption) (*${3:PackageName}.${2:Method1}Response, error)",
      "}",
      "",
      "//TODO add this to the service",
      "",
      "\t${1:serviceName}ServiceClient             ${1:serviceName}ServiceClient",
      "",
      "//TODO create client",
      "",
      "\t${1:serviceName}ServiceClient, err := ${3:PackageName}.NewClient(serviceUser)",
      "\tif err != nil {",
      "\t\tpanic(err)",
      "\t}",
      "",
      "//TODO use it",
      "",
      "\t\t${1:serviceName}ServiceClient:             ${1:serviceName}ServiceClient,",
      "",
      "//TODO add to _mock.go file",
      "",
      "// ${1:serviceName}ServiceClientMock",
      "",
      "var _ ${1:serviceName}ServiceClient = (*${1:serviceName}ServiceClientMock)(nil)",
      "",
      "type ${1:serviceName}ServiceClientMock struct {",
      "\t${2:Method1}Func func(ctx context.Context, req *${3:PackageName}.${2:Method1}Request) (*${3:PackageName}.${2:Method1}Response, error)",
      "}",
      "",
      "func (m *${1:serviceName}ServiceClientMock) ${2:Method1}(ctx context.Context, req *${3:PackageName}.${2:Method1}Request, opts ...grpc.CallOption) (*${3:PackageName}.${2:Method1}Response, error) {",
      "\tif m.${2:Method1}Func == nil {",
      "\t\treturn nil, unimplementedError(\"${2:Method1}\", req)",
      "\t}",
      "\treturn m.${2:Method1}Func(ctx, req)",
      "}",
      "//TODO update Buildfile.yaml",
      "//TODO add policy ${1:serviceName}${2:Method} to the domain_service_users.go"
    ]
  },
  "errgroup": {
    "prefix": "errgroup",
    "body": [
      "g, ctx := errgroup.WithContext(ctx)",
      "",
      "g.Go(func() error {",
      "\treturn function(ctx)",
      "})",
      "",
      "if err := g.Wait(); err != nil {",
      "\treturn err",
      "}"
    ]
  },
  "toWhereInQuery": {
    "prefix": "toWhereInQuery",
    "body": [
      "func toWhereInQuery[T int64 | string](fieldName, argName string, filterValues []T) (wawidb.SqlQuery, []sql.NamedArg) {",
      "\tvar q strings.Builder",
      "\tq.WriteString(fmt.Sprintf(\"%s IN (\", fieldName))",
      "\tfor i := range len(filterValues) {",
      "\t\tfmt.Fprintf(&q, \":%s_%d\", argName, i)",
      "\t\tif i != len(filterValues)-1 {",
      "\t\t\tq.WriteString(\", \")",
      "\t\t}",
      "\t}",
      "\tq.WriteString(\")\")",
      "",
      "\targs := make([]sql.NamedArg, 0, len(filterValues))",
      "\tfor i, value := range filterValues {",
      "\t\targName := fmt.Sprintf(\"%s_%d\", argName, i)",
      "\t\targs = append(args, sql.NamedArg{Name: argName, Value: value})",
      "\t}",
      "\treturn wawidb.SqlQuery(q.String()), args",
      "}"
    ]
  },
  "pointTo": {
    "prefix": "pointTo",
    "body": [
      "func pointTo[element any](s element) *element {",
      "\treturn &s",
      "}"
    ]
  },
  "sortFunc": {
    "prefix": "sortFunc",
    "body": [
      "slices.SortFunc(${1:slice}, func(a, b ${2:type}) int {",
      "\treturn cmp.Or(",
      "\t\tcmp.Compare(a.${3:Field}, b.${3:Field}),",
      "\t\t$0",
      "\t)",
      "})"
    ]
  }
}
